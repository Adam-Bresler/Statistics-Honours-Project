colnames(data[c(11,12)])
#Eventually, add this into loop
colnames(data)[c(11,12)] <- c("Average_serve_rating", "average_return_rating")
View(data)
#Eventually, add this into loop
colnames(data)[c(11,12)] <- c("average_serve_rating", "average_return_rating")
View(data)
library(dplyr)
library(dplyr)
library(tidyverse)
library(lubridate)
library(magrittr)
predictive <- data %>% filter(Match_ID)
predictive <- data %>% matches(Match_ID)
data <- data[,-1]
predictive <- data %>% group_by(Match_ID)
View(predictive)
predictive <- data %>% group_by(Match_ID, add = TRUE)
View(predictive)
predictive <- data %>% group_by(Match_ID, add = TRUE) %>% group_vars()
predictive <- data %>% group_by(Match_ID, add = TRUE) %>% arrange(by_group = TRUE)
predictive <- data %>% group_by(Match_ID) %>% arrange(by_group = TRUE)
predictive <- data %>% group_by(Match_ID) %>% arrange(by_group = TRUE)
rm(predictive)
predictive <- data %>% group_by(Match_ID) %>% arrange(by_group = TRUE)
predictive <- data %>% group_by(Match_ID)
predictive <- arrange(predictive, .by_group = TRUE)
View(predictive)
predictive <- reshape(data, idvar=c("MatchID"), direction="wide")
predictive <- reshape(data, idvar="MatchID" , direction="wide")
predictive <- reshape(data, idvar="MatchID" , direction="wide")
predictive <- reshape(data, idvar="MatchID", timevar = "Match_order", direction="wide")
predictive <- reshape(data, idvar="MatchID", timevar = "average_serve_rating", direction="wide")
predictive <- data %>% group_by("MatchID")
predictive <- data %>% group_by("MatchID") %>% summarise()
View(predictive)
predictive <- data %>% gather(name:average_return_rating)
gathercols <- colnames(data)[-1]
predictive <- data %>% gather(gathercols)
View(predictive)
predictive <- data %>% gather_(gathercols)
predictive <- gather(data = data, key_col = "MatchID")
predictive <- data %>% group_by("MatchID", add = TRUE) %>% group_vars()
predictive <- which(apply(data, 2, function(x) length(unique(x))) != 1)
predictive
data <- read.csv("rolling_average_serve_return.csv")
data <- data[,-1]
#Eventually, add this into loop
colnames(data)[c(10,11)] <- c("average_serve_rating", "average_return_rating")
predictive <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)
predictive2 <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)%>%
select(c(1,10,11))
predictive3 <- predictive[seq(1,52670,2),-c(10,11)]
first_player<-predictive2[seq(1,52670,2),-1]
second_player<-predictive2[seq(2,52670,2),-1]
difference <- first_player-second_player
predictive_dataset <- cbind(predictive3,difference)
colnames(data)[c(2,3)] <- c("player_a", "player_b")
rm(predictive, predictive2, predictive3, second_player, first_player)
colnames(predictive_dataset)[c(2,3)] <- c("player_a", "player_b")
View(predictive_dataset)
predictive_dataset$wl <- ifelse(predictive_dataset$wl == 'winner', "Player A", "Player B")
View(predictive_dataset)
colnames(predictive_dataset)[c(2,3)] <- c("Player_A", "Player_B")
View(data)
predictive <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)
View(predictive)
str(predictive_dataset)
rm(predictive, predictive2, predictive3, second_player, first_player, difference)
predictive_dataset$wl <- as.factor(predictive_dataset$wl)
str(predictive_dataset)
predictive_dataset$wl <- as.factor(predictive_dataset$wl)
str(predictive_dataset)
View(predictive_dataset)
train <- predictive_dataset[ind, ]
ind <- 1:23731
train <- predictive_dataset[ind, ]
test <- predictive_dataset[-ind, ]
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train)
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train)
View(train)
which(is.na(train$wl))
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train, family=binomial)
mod
summary(mod)
plot(mod)
predict(mod, data = test)
y.hat <- predict(mod, data = test)
y.hat <- predict(mod, newdata = test)
table(y.hat, test$wl)
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, 1,2)
threshold <- 0.5
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, 1,2)
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
table(y.hat, test$wl)
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player B", "Player A")
table(y.hat, test$wl)
table(test$wl)
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player A")
table(y.hat, test$wl)
table(y.hat, test$wl)
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
table(y.hat, test$wl)
threshold <- 0.7
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
table(y.hat, test$wl)
threshold <- 0.2
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
table(y.hat, test$wl)
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
table(y.hat, test$wl)
conf_matrix <- table(y.hat, test$wl)
sens[i] <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec[i] <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
sens <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
sens
spec
sens + spec
diag(conf_matrix)
sum(diag(conf_matrix))/2604
sum(diag(conf_matrix))/sum(conf_matrix)
threshold <- 0.4
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
threshold <- 0.5
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
threshold <- 0.53
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
sum(conf_matrix)
View(train)
conf_matrix
y.hat
view(y.hat)
which(is.na(y.hat))
View(predictive_dataset)
plot(predict(mod))
plot(predict(mod, type = 'response'))
plot(sort(predict(mod, type = 'response')))
plot(sort(predict(mod, type = 'response')), type = "l")
threshold <- 0.42
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
which(is.na(y.hat))
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
sens <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
View(test)
which(is.na(y.hat))
test[which(is.na(y.hat)), ]
View(data)
test[which(is.na(data$average_serve_rating)), ]
which(is.na(data$average_serve_rating))
test[which(is.na(data$erve_rating)), ]
test[which(is.na(data$serve_rating)), ]
data[which(is.na(data$serve_rating)), ]
data[which(is.na(data$average_serve_rating)), ]
data[which(is.na(data$average_return_rating)), ]
data[which(is.na(data$return_rating)), ]
#Didnt exclude NA!
which(is.na(data$return_rating))
#Didnt exclude NA!
data <- data[-which(is.na(data$return_rating)),]
which(is.na(data$serve_rating))
library(dplyr)
library(tidyverse)
library(lubridate)
library(magrittr)
w_dat <- read.csv("finaldata2.csv")
w_dat <- w_dat[, -1]
w_dat$tournament_date <- lubridate::as_date(w_dat$tournament_date)
#Select serve and return ratings as our inital features
w_dat <- w_dat[, c(1:4, 6, 18, 36, 37, 39)]
data <- w_dat
months = 24
#Didnt exclude NA!
data <- data[-which(is.na(data$serve_rating)),]
average_past_games <- function(data, columns = c(5, 6), months = 24){
n <- nrow(data)
player <- unique(data$name)
return_matrix <- matrix(0, nrow = 1, ncol = ncol(data) + length(columns))
colnames(return_matrix) <- c(colnames(data), colnames(data)[columns])
for(i in player){
dat <- data %>% filter(name == i)
player_dat <- matrix(0, nrow = 1, ncol = ncol(data) + length(columns))
colnames(player_dat) <- colnames(return_matrix)
for(j in 1:nrow(dat)){ # This include all matches in a tournament, even if we are in the quarters. Thus, we need to remove the semis etc
matches <- dat %>% filter(dat$tournament_date <= dat$tournament_date[j] & dat$tournament_date >= (dat$tournament_date[j] - months(months)))
if(j == 1){ #The first game has no ytd from before
average <- as.data.frame(t(c(0,0)))
colnames(average) <- colnames(data)[columns]
}
else{
ind <- which(matches$Match_ID == dat$Match_ID[j])  #Find which j we are in matches, and throw older stuff away
matches <- matches[1:(ind-1), ]
average <- matches %>% select(columns) %>% summarise_if(is.numeric, mean)
}
player_dat <- rbind(player_dat, cbind(dat[j, ], average))
}
return_matrix <- rbind(return_matrix, player_dat[-1, ])
}
return(return_matrix[-1, ])
}
rolling_average_serve_return <- average_past_games(w_dat)
write.csv(rolling_average_serve_return, file = "C:/Users/Adam Bresler/Documents/GitHub/Statistics-Honours-Project/Data/rolling_average_serve_return.csv")
# Creating the predictive ----------------------------------------------------
data <- read.csv("rolling_average_serve_return.csv")
data <- data[,-1]
#Eventually, add this into loop
colnames(data)[c(10,11)] <- c("average_serve_rating", "average_return_rating")
predictive <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)
predictive2 <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)%>%
select(c(1,10,11))
predictive3 <- predictive[seq(1,52670,2),-c(10,11)]
first_player<-predictive2[seq(1,52670,2),-1]
second_player<-predictive2[seq(2,52670,2),-1]
difference <- first_player-second_player
predictive_dataset <- cbind(predictive3,difference)
rm(predictive, predictive2, predictive3, second_player, first_player, difference)
colnames(predictive_dataset)[c(2,3)] <- c("Player_A", "Player_B")
predictive_dataset$wl <- ifelse(predictive_dataset$wl == 'winner', "Player A", "Player B")
predictive_dataset$wl <- as.factor(predictive_dataset$wl)
ind <- 1:23731
train <- predictive_dataset[ind, ]
test <- predictive_dataset[-ind, ]
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train, family = binomial)
summary(mod)
plot(sort(predict(mod, type = 'response')), type = "l")
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
data[which(is.na(data$return_rating)), ]
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
sens <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
#Didnt exclude NA!
data <- data[-which(is.na(data$serve_rating)),]
average_past_games <- function(data, columns = c(5, 6), months = 24){
n <- nrow(data)
player <- unique(data$name)
return_matrix <- matrix(0, nrow = 1, ncol = ncol(data) + length(columns))
colnames(return_matrix) <- c(colnames(data), colnames(data)[columns])
for(i in player){
dat <- data %>% filter(name == i)
player_dat <- matrix(0, nrow = 1, ncol = ncol(data) + length(columns))
colnames(player_dat) <- colnames(return_matrix)
for(j in 1:nrow(dat)){ # This include all matches in a tournament, even if we are in the quarters. Thus, we need to remove the semis etc
matches <- dat %>% filter(dat$tournament_date <= dat$tournament_date[j] & dat$tournament_date >= (dat$tournament_date[j] - months(months)))
if(j == 1){ #The first game has no ytd from before
average <- as.data.frame(t(c(0,0)))
colnames(average) <- colnames(data)[columns]
}
else{
ind <- which(matches$Match_ID == dat$Match_ID[j])  #Find which j we are in matches, and throw older stuff away
matches <- matches[1:(ind-1), ]
average <- matches %>% select(columns) %>% summarise_if(is.numeric, mean)
}
player_dat <- rbind(player_dat, cbind(dat[j, ], average))
}
return_matrix <- rbind(return_matrix, player_dat[-1, ])
}
return(return_matrix[-1, ])
}
rolling_average_serve_return <- average_past_games(w_dat)
data <- data[-which(is.na(data$serve_rating)),]
View(rolling_average_serve_return)
#Didnt exclude NA!
data <- data[-which(is.na(rolling_average_serve_return$serve_rating)),]
which(is.na(rolling_average_serve_return$serve_rating))
library(dplyr)
library(tidyverse)
library(lubridate)
library(magrittr)
w_dat <- read.csv("finaldata2.csv")
w_dat <- w_dat[, -1]
setwd("~/GitHub/Statistics-Honours-Project/Data")
w_dat <- read.csv("finaldata2.csv")
w_dat <- read.csv("finaldata2.csv")
w_dat <- w_dat[, -1]
w_dat$tournament_date <- lubridate::as_date(w_dat$tournament_date)
#Select serve and return ratings as our inital features
w_dat <- w_dat[, c(1:4, 6, 18, 36, 37, 39)]
data <- w_dat
months = 24
which(is.na(w_dat$serve_rating))
#Didnt exclude NA!
w_dat <- w_dat[-which(is.na(w_dat$serve_rating)),]
w_dat <- w_dat[, c(1:4, )]
View(w_dat)
average_past_games <- function(data, columns = c(5, 6), months = 24){
n <- nrow(data)
player <- unique(data$name)
return_matrix <- matrix(0, nrow = 1, ncol = ncol(data) + length(columns))
colnames(return_matrix) <- c(colnames(data), colnames(data)[columns])
for(i in player){
dat <- data %>% filter(name == i)
player_dat <- matrix(0, nrow = 1, ncol = ncol(data) + length(columns))
colnames(player_dat) <- colnames(return_matrix)
for(j in 1:nrow(dat)){ # This include all matches in a tournament, even if we are in the quarters. Thus, we need to remove the semis etc
matches <- dat %>% filter(dat$tournament_date <= dat$tournament_date[j] & dat$tournament_date >= (dat$tournament_date[j] - months(months)))
if(j == 1){ #The first game has no ytd from before
average <- as.data.frame(t(c(0,0)))
colnames(average) <- colnames(data)[columns]
}
else{
ind <- which(matches$Match_ID == dat$Match_ID[j])  #Find which j we are in matches, and throw older stuff away
matches <- matches[1:(ind-1), ]
average <- matches %>% select(columns) %>% summarise_if(is.numeric, mean)
}
player_dat <- rbind(player_dat, cbind(dat[j, ], average))
}
return_matrix <- rbind(return_matrix, player_dat[-1, ])
}
return(return_matrix[-1, ])
}
rolling_average_serve_return <- average_past_games(w_dat)
View(rolling_average_serve_return)
write.csv(rolling_average_serve_return, file = "C:/Users/Adam Bresler/Documents/GitHub/Statistics-Honours-Project/Data/rolling_average_serve_return.csv")
# Creating the predictive ----------------------------------------------------
data <- read.csv("rolling_average_serve_return.csv")
data <- data[,-1]
#Eventually, add this into loop
colnames(data)[c(10,11)] <- c("average_serve_rating", "average_return_rating")
View(data)
predictive <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)
predictive2 <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)%>%
select(c(1,10,11))
predictive3 <- predictive[seq(1,52670,2),-c(10,11)]
first_player<-predictive2[seq(1,52670,2),-1]
second_player<-predictive2[seq(2,52670,2),-1]
difference <- first_player-second_player
predictive_dataset <- cbind(predictive3,difference)
rm(predictive, predictive2, predictive3, second_player, first_player, difference)
colnames(predictive_dataset)[c(2,3)] <- c("Player_A", "Player_B")
predictive_dataset$wl <- ifelse(predictive_dataset$wl == 'winner', "Player A", "Player B")
predictive_dataset$wl <- as.factor(predictive_dataset$wl)
View(predictive_dataset)
which(is.na(data$return_rating))
which(is.na(data$serve_rating))
which(is.na(data$average_serve_rating))
ind <- 1:23731
train <- predictive_dataset[ind, ]
test <- predictive_dataset[-ind, ]
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train, family = binomial)
summary(mod)
plot(sort(predict(mod, type = 'response')), type = "l")
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
data[which(is.na(data$average_serve_rating)), ]
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
sum(conf_matrix)
which(is.na(y.hat))
y.hat[which(is.na(y.hat)), ]
y.hat[which(is.na(y.hat))]
View(test)
View(test)
nrow(test)
y.hat[which(is.na(y.hat))]
# Creating the predictive ----------------------------------------------------
data <- read.csv("rolling_average_serve_return.csv")
data <- data[,-1]
#Eventually, add this into loop
colnames(data)[c(10,11)] <- c("average_serve_rating", "average_return_rating")
predictive <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)
predictive2 <- data %>%
group_by(Match_ID)%>%arrange(.by_group = TRUE)%>%
select(c(1,10,11))
predictive3 <- predictive[seq(1,52668,2),-c(10,11)]
first_player<-predictive2[seq(1,52668,2),-1]
second_player<-predictive2[seq(2,52668,2),-1]
difference <- first_player-second_player
predictive_dataset <- cbind(predictive3,difference)
rm(predictive, predictive2, predictive3, second_player, first_player, difference)
colnames(predictive_dataset)[c(2,3)] <- c("Player_A", "Player_B")
predictive_dataset$wl <- ifelse(predictive_dataset$wl == 'winner', "Player A", "Player B")
predictive_dataset$wl <- as.factor(predictive_dataset$wl)
ind <- 1:23731
train <- predictive_dataset[ind, ]
test <- predictive_dataset[-ind, ]
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train, family = binomial)
summary(mod)
plot(sort(predict(mod, type = 'response')), type = "l")
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
sens <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
sum(conf_matrix)
threshold <- 0.32
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
sum(diag(conf_matrix))/sum(conf_matrix)
sens <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
conf_matrix
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train, family = binomial)
summary(mod)
plot(sort(predict(mod, type = 'response')), type = "l")
threshold <- 0.32
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
conf_matrix
sum(diag(conf_matrix))/sum(conf_matrix)
sens <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
conf_matrix
sum(diag(conf_matrix))/sum(conf_matrix)
mod <- glm(wl ~ average_serve_rating + average_return_rating + average_serve_rating*average_return_rating, data = train, family = binomial)
summary(mod)
plot(sort(predict(mod, type = 'response')), type = "l")
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
conf_matrix
sum(diag(conf_matrix))/sum(conf_matrix)
threshold <- 0.5
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
conf_matrix
sum(diag(conf_matrix))/sum(conf_matrix)
sens <- conf_matrix[2,2]/(conf_matrix[1,2]+conf_matrix[2,2])
spec <- conf_matrix[1,1]/(conf_matrix[1,1]+conf_matrix[2,1])
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
conf_matrix
sum(diag(conf_matrix))/sum(conf_matrix)
mod <- glm(wl ~ average_serve_rating + average_return_rating, data = train, family = binomial)
summary(mod)
plot(sort(predict(mod, type = 'response')), type = "l")
threshold <- 0.3
y.hat <- ifelse(predict(mod, newdata = test, type = 'response') > threshold, "Player A", "Player B")
y.hat[which(is.na(y.hat))]
conf_matrix <- table(y.hat, test$wl)
conf_matrix
sum(diag(conf_matrix))/sum(conf_matrix)
# Decision Tree --------------------------------------------------------------
library(tree)
tree_titanic_g
library(tree)
tree_tennis<- tree(wl ~ average_serve_rating + average_return_rating, data = train, split = 'deviance')
summary(tree_tennis)
tree_tennis
plot(tree_tennis)
text(tree_tennis, cex = 0.9)
library(tree)
tree_tennis<- tree(wl ~ average_serve_rating + average_return_rating, data = train, split = 'deviance')
summary(tree_tennis)
tree_tennis
plot(tree_tennis)
text(tree_tennis, cex = 0.9)
yhat<- predict(tree_tennis,  test, type = 'class')
(c_mat <- table(yhat, test$Survived))
sum(diag(c_mat))/nrow(test)*100
1 - sum(diag(c_mat))/nrow(test))
(c_mat <- table(yhat, test$wl)
sum(diag(c_mat))/nrow(test)*100
1 - sum(diag(c_mat))/nrow(test))
(c_mat <- table(yhat, test$wl))
sum(diag(c_mat))/nrow(test)*100
1 - sum(diag(c_mat))/nrow(test))
1 - sum(diag(c_mat))/nrow(test)
library(randomForest)
rf_tennis <- randomForest(wl ~ average_serve_rating + average_return_rating, data = train,
ntree = 1000, #no mtry argument, keep it defualt
importance = TRUE,
do.trace = 100)
rf_tennis
plot(rf_tennis$err.rate[, 'OOB'], type = 's', xlab = 'Number of trees', ylab = 'OOB error')
rf_pred <- predict(rf_tennis, newdata = test)
table(rf_pred, test$wl)
(rf_err <- mean(rf_pred != test$wl))
# Boosting -------------------------------------------------------------------
library(gbm)
gbm_lib <- gbm(wl ~ average_serve_rating + average_return_rating, data = train,
bag.fraction = 1) # default adds bagging
gbm_lib <- gbm(wl ~ average_serve_rating + average_return_rating, data = train,
distribution = 'laplace',
bag.fraction = 1) # default adds bagging
yhat_gbm <- predict.gbm(gbm_lib, dat, n.trees = ntrees)
yhat_gbm <- predict.gbm(gbm_lib, test)
(mse_gbm <- mean((test$wl - yhat_gbm)^2))
